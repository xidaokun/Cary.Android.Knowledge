#### 面向对象三大特性，五大原则
- 封装
  把客观对象特征和行为抽象并包装成为类中的数据和方法
- 继承
  子类继承父类的特征和行为，使得子类对象具有父类的实例和方法
- 多态
  同一行为具有不同表现形式；实现方式有重载和重写
  比如按下F1键，如果在Word下弹出的就是Word帮助，在Windows下弹出的就是Windows帮助
  
  
 #### 设计模式
   java中一共有23种设计模式：
1. 创建型，描述怎么创建对象的模式
      - 单利模式
      - 建造者模式
      - 工厂模式
      - 抽象工厂模式
      - 原型模式
2. 结构型，描述如何将类或对象按照某种规则组成更大机构
       - 装饰模式
       - 适配器模式
       - 外观模式
         对外提供统一接口，外部不需要关心内部具体实现
       - 组合模式
       - 享元模式
       - 桥接模式
       - 代理模式
3. 行为型，描述类和对象之间怎么协作，怎么分配职责
     - 观察者模式
     - 中介者模式
     - 访问者模式
     - 命令行模式
     - 策略模式
     - 责任链模式
     - 备忘录模式
     - 解释器模式
     - 模版方法模式
     - 状态行模式

#### Android中常见的集中设计模式
1. AlertDialog，Notification使用了Builder建造者模式
2. BaseActivity抽象工厂模式
3. Okhttp内部使用责任链模式完成每个Interceptor拦截器调用
4. RxJava观察者模式
5. ListView、RecyclerView适配器模式
6.Context外观模式	

#### 集合框架
一，类整体结构

Collection类结构图：
![[Pasted image 20210516222340.png]]

Map类结构图：
![[Pasted image 20210516222418.png]]

List：有序，可重复，通过索引查询，插入和删除伴随数据移动，速度慢

Set：无序，不可重复；重复元素会被覆盖，元素虽然无放入顺序，但元素在set中的位置是对象的HashCode决定的，set只能用迭代器遍历元素

Queue：先进先出(FIFO)的容器，不允许随机访问队列中的元素

Map：键值对，键唯一，值多个

二，List实现类
 1. ArrayList（非线程安全）
   它是动态数组结构，支持随机存取，插入和删除需要移动数组元素，因此效率较低
   
 2. LinkedList（非线程安全）
   它是双向链表结构，每个元素都使用引用来记录前一个元素和后一个元素，因此插入和删除是方便的，但遍历只能从一端开始遍历，知道查询到对象
   
 3. Vector（线程安全）
   它是动态数组结构，大部分方法和ArrayList相同，不同的是Vector是线程安全的
   
 4. Stack（线程安全）
   是Vector的子类，也是动态数组结构，但它是先进后出，即栈
   
三， Set实现类
  1. HashSet
	底层基于HashMap的k实现，当向HashSet集合中添加一个对象时，首先调用该对象的hashCode()方法来确定元素的存储位置，再调用对象的equals方法来确保该位置没有重复元素
  2. LinkHashSet
	底层基于LinkedHashMap的k实现，特性通LinkedHashMap
  3. TreeSet
    基于TreeMap的k实现的，特性通TreeMap；

四，Map实现类
  1. HashMap（非线程安全）
    是基于哈希表实现的，数据是无序的，可以但只能又一个null key/vaule
  2. TreeMap
   是基于二叉树实现的，数据已自动排好序，不允许放入null key/value；适用于按自然顺序或自定义顺序遍历键(key)
   3. HashTable（线程安全）
     相比HashMap是线程安全的，HashTable不允许null key/value
   4. HashMap和HashTable底层都是基于数组+链表结构实现的

五，[[HashMap、ConcurrentHashMap实现原理]]

#### 反射
java反射机制是在运行状态中，对于任意一个类和对象，都能够拿到这个类和对象的所有属性和方法；反射需要先拿到这个类的字节码
1. 获取字节码三种方式
  - Class.forName(className)
  - 类名.class
  - this.getClass()
 
 2. 然后将字节码中的方法、变量、构造函数映射成Method、Field、Constructor

#### 泛型
1. 泛型本质是参数化类型，即数据类型被指定为一个参数(把类型当作参数来使用)，可以用来类、接口和方法中
2. java 1.5 之前，没有泛型情况下，通过对类型Object来实现参数的“任意化”，确定是要显示的强制类型转换，而这种转换是在开发者预知实际参数类型情况下进行的
3. 泛型不能是简单类型；泛型可以extends；泛型的参数类型可以为通配符类型
4. 泛型擦除：泛型信息只存在代码编译阶段，进入JVM之前，泛型信息即被擦除


#### 注解
1. 一种元数据标记，可以加在包、类、字段、方法、方法参数以及局部变量上
2. 注解会被@interface标记
3. 可以通过元注解(@Target、@Retention、@Documented、@Inherited)自定义注解

#### 运行时注解和编译时注解区别
1. 保留阶段不同，前者保留到运行时，后者保留到编译
2. 原理不同，前者是应用Java反射机制，而后者通过APT、AbstractProcessor
3. 性能上后者比利用反射的前者要高


#### 字符集和字符编码
- ACSII和Unicode都是字符集，而UTF-8，UTF-16是Unicode字符集存取方式
- Unicode字符集
  Unicode字符集一开始提出的时候，认为码值范围为0-65535（0-FFFF，这一段区域也被称为Basic Multilingual Plane, 简称**BMP**）就可以表示所有的字符，但随着时代发展，0-FFFF也不够容纳所有字符，因此**Unicode划出了一个代理区：D800-DFFF， Unicode标准规定U+D800 - U+DFFF的值不对应于任何字符**。这也是为什么有些人说：有些字符需要用两个Unicode字符去表示的原因。

  目前Unicode的编码空间为0-10FFFF，根据第一段落可以得知，当某个字符的Unicode码值落在0-FFFF时，则只用一个Unicode字符即可表示，否则就会用两个。
  
- UTF-8编码规则
   1. 对于单个字节符号，字节第一位设为0，后面7位为这个符号的Unicode码值
   2. 对于n字节的符号(n > 1)，第一个字节的前n位都设置为1，第n+1为设为0，后面字节的前两位一律设为10，剩下的二进制位全部为Unicode码值
   3. 对ACSII码完全兼容
   ![[Pasted image 20210517082148.png]]
 - UTF-16编码规则
     1. 对应0x0000-0xFFFF范围的码值
        这16位就是Unicode码值
     2. 对应0x10000-0x10FFFF的码值
        取后20位，分位高10位和低10位；在高位上加上0xD800(得到值范围为0xD800—0xDBFF)，将低位加上0xDC00(得到值范围为0xDC00—0xDFFF)；然后将处理后的高位值放到前两个字节，将处理后的低位值放到后两个字节
   
 #### Java char历史问题
 1. java中char类型目前已经**偏离**了其**原有的语意**，也就是一个char类型表示的并**不完全**是我们理解上的任意一个字符，这是由于java中char类型所使用的utf-16编码的历史原因造成的。
 2. **_utf-16的历史_**
  最开始java设计的时候**char确实是用来表示任何一个unicode字符**的，当时的utf-16还叫作**UCS-2**，unicode也没有收录那么多的字符，只是收录了BMP那一部分。
  所以UCS-2专家们的美好愿望是使用**固定两个字节**足以表示**所有的字符**了，当时也确实是如此。
  java因此**决定采用UCS-2**来表示char类型，毕竟UCS-2**固定**两个字节，而且能表示**所有**的字符。
  后面UCS-2的专家们就**翻车**了，unicode太**低估**了世界民族文字的博大精深，不断收录了新的字符，不断的壮大，UCS-2的专家们发现**两个字节不足**以表示unicode新收录的那些字符了，只能增加字节，所以有了后来的utf-16，并且utf-16得**兼容**UCS-2，因为当时很多应用商已经**习惯**了UCS-2的编码，只能基于UCS-2进行增强。
至此utf-16从**固定两字节**的UCS-2进化为现在**不定长**的utf-16。

3. **_java对应utf-16演变的修改_**
 java设计者当时是基于UCS-2**固定**两个字节能表示**所有unicode**字符来设计的char类型，既然UCS-2演化为了utf-16，由**定长变为不定长**，所以也得跟着调整，当时char类型已经是固定两个字节了，所以char就是固定两个字节，因此如今也**只能表示**BMP范畴的字符，当然这包括了BMP范畴内的那些无效码位，也就是**char能够表示high/low surrougate**。
 
  总结：Unicode一开始范围定小了，后又划出去一块拓展区，进一步缩小了BMP范围，而java char固定为2个字节，导致不能完全存取所有的Unicode码值
  这感觉就像开发者已经实现了预期的功能，然后产品经理跑过来说需求变更了...
  
  
  #### java存储
   1. 寄存器
     位于CPU中，由CPU按需进行分配，数量非常有限
   2. 栈
     位于RAM中，CPU通过栈指针来进行操作，基本类型和对象引用存储在栈中
   3. 堆
     存储java对象，动态分配堆内存
   4. 常量存储区
     常量存储在这里，比如string字面量
   5. 静态存储区
    程序的整个运行期间都有效的数据，比如static变量
   6. 非随机存储区
     持久化数据
	 
#### java堆内存限制
JVM初始分配的**内存**由-Xms指定，默认是物理**内存**的1/64；JVM最大分配的**内存**由-Xmx 指定，默认是物理**内存**的1/4。 默认空余**堆内存**小于40%时，JVM就会增大**堆**直到-Xmx的最大**限制**；空余**堆内存**大于70%时，JVM会减少**堆**直到- Xms的最小**限制**。

#### java字符串创建
Java 中创建字符串对象有两种方式。

String s1 \= "abc";
String s2 \= new String("abc");

两种方法有些区别。 第一种方法，仅仅是一个赋值语句，在创建的时候，JVM 会检查在字符串池中，是否已经存在该字符串，如果已经存在了，那么会返回这个字符串的引用给变量 s。如果不存在，那么会创建一个 abc 字符串对象，再赋值给 s1。因此，这句话可能只创建 1 个或者 0 个对象。

第二种方法会在内存中创建 1 个或者 2 个对象。把 new String(“abc”) 这句话拆成两个部分来看，一个是”abc”, 另一个是 new String()。如果 abc 字符串已经在字符串池中存在了，那么就不需要在创建 abc 字符串的对象了，但是 new String 这行代码会再构造出一个和 abc 一样的字符串，并且是放在堆上。

#### Serializable
一，什么是序列化
1. **Java序列化**就是把Java对象转换为字节序列的过程
2. **Java反序列化**是指把字节序列恢复为Java对象的过程
3. Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。

二，序列化特点
1. 如果某个类能够被序列化，其子类也可以被序列化。声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态， transient代表对象的临时数据
2. 使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大
三，如何实现序列化
将需要序列化的类实现Serializable接口就可以了，Serializable接口中没有任何方法，可以理解为一个标记，即表明这个类可以序列化
四，应用场景
1. 可以进程间通信，将Java对象进行序列化为字节序列，传送给另一个进程，另一个进程收到信息后，再进行反序列化，即得到对象信息
2. 通过序列化实现远程通信，也就是在网络上传送对象的字节序列，用于网络传输对象
3. 实现数据对象的持久化，通过序列化可把数据永久地保存至硬盘（通常存放在文件里），用于持久化对象
五，serialVersionUID作用
serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException
六，操作
可以使用类ObjectInputStream和ObjectOutputStream
七，其他序列化方式
 Json序列化，xml序列化

#### java字符串最大长度
- 字面量形式
  对于字符串可以承受的最大长度，要分为2个阶段，一个是编译时期(也就是你代码定义了一个String字符串，String s= "xiaohu")，一个是运行时期(指在程序运行过程中)
  
  1. 常量池的限制：当我们用字符串字面量定义String时，字符串会被存入常量池中，常量池中每个常量都有一个表，都有自己对应类型，java中的UTF-8编码的Unicode字符串在常量池中对应的是CONSTANT_Utf8_info类型
     ![[Pasted image 20210517093042.png]]
     u2的length值表明字符串长度是多少个u2，u2是无符号的16位整数，因此字符串允许长度为2^16-1=65535
  2. 编译器的限制： 在Javac编译器下，字符串String的最大长度限制也即是U2类型所能表达的最大长度65534。避开javac最大长度是65535
  3. 运行期字符串限制
    String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX\_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。
   
- new形式
  1. new String(bytes)内部是采用了一个字符数组，其对应的虚拟机指令是new array \[int\] ，数组理论最大个数为Integer.MAX\_VALUE，有些虚拟机需要一些头部信息，所以MAX\_ARRAY\_SIZE = Integer.MAX\_VALUE - 8。
  2. 还受堆内存大小限制
	 
#### String，StringBuffer，StringBuilder区别
1. String(非线程安全)
String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。

2. StringBuilder(非线程安全)
StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选

3. StringBuffer(线程安全)
StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。

#### 接口和抽象类的意义
接口：
  规范、扩展、回调
抽象类：
  为子类提供一个公共的类型，封装子类中重复内容，定义抽象方法，子类可以有不同实现，但定义是一致的
#### 接口和抽象类区别
共同点：
  - 都是上层抽象层
  - 都不能被实例化
  - 都能包含抽象方法

区别：
  - 抽象类可以有实现方法
  - 单继承，多实现
  - 抽象类可以有构造器
  - 接口方法默认修饰符为public，不能使用其他修饰符
  - 抽象类除了不能实例化，其他和java普通类没有啥区别

#### 内部类
1. 含义：将一个类定义放在另一个类中；
2. 分类
- 成员内部类
- 局部内部类
- 匿名内部类
- 静态内部类

3. 特点
- 内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能
 - 编译器会默认为成员内部类添加一个只想外部类对象的引用
 - 静态内部类不依赖外部类，即可以在不创建外部类对象的情况下创建内部类
 - 静态内部类不持有指向外部类对象的引用

4. 使用场景
 - 多继承
 - 业务相同可以封装在一起，逻辑上比较完整
 - 写法简洁，如内部类

#### java类加载过程
例子：Person p = new Person()
1. 因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;
2. 执行该类中的static代码块，如果有的话，给Person.class类进行初始化;
3. 在堆内存中开辟空间分配内存地址;
4. 在堆内存中建立对象的特有属性，并进行默认初始化;
5. 对属性进行显示初始化;
6. 对对象进行构造代码块初始化;
7. 对对象进行与之对应的构造函数进行初始化;
8. 将内存地址付给栈内存中的p变量。

#### java对象生命周期
在Java中，对象的生命周期包括以下几个阶段：

1.创建阶段(Created)
JVM 加载类的class文件 此时所有的static变量和static代码块将被执行 加载完成后，对局部变量进行赋值（先父后子的顺序） 再执行new方法 调用构造函数 一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段。

2.应用阶段(In Use)
对象至少被一个强引用持有着。

3.不可见阶段(Invisible)
当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。 简单说就是程序的执行已经超出了该对象的作用域了。

4.不可达阶段(Unreachable)
对象处于不可达阶段是指该对象不再被任何强引用所持有。 与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。

5.收集阶段(Collected，执行finalize阶段)
当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。

6.终结阶段(Finalized，执行finalize后等待gc阶段)
当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。

7.对象空间重分配阶段(De-allocated)
垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段。


#### java中比较对象
1. == 是判断对象地址是否一样，即引用是否指向同一个对象地址
2. hashCode()是Object的native方法，用于获取对象哈希值
3. equals()是Object的实例方法，默认情况下equals与\=\=等价
4. 在java集合中，判断两个对象是否相等规则是：
  - 判断两个对象的hashCode是否相等
  - 判断两个对象用equals运算是否相等

#### java IO操作
一. 分类
-  字节流和字符流，前者读取单个字节，后者读取单个字符
-  从数据源上分类
   1、文件：FileInputStream、FileOutputStream、FileReader、FileWriter
   2、数组：
     -   2.1、字节数组（byte\[\]）：ByteArrayInputStream、ByteArrayOutputStream
     -   2.2、字符数组（char\[\]）：CharArrayReader、CharArrayWriter

   3、管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter
   4、基本数据类型：DataInputStream、DataOutputStream
   5、缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter
   6、打印：PrintStream、PrintWriter
   7、对象序列化反序列化：ObjectInputStream、ObjectOutputStream
   8、转换：InputStreamReader、OutputStreWriter
   9、~~字符串（String）~~**Java8中已废弃**：~~StringBufferInputStream、StringBufferOutputStream、StringReader、StringWriter~~

二. 操作类图结构
![[Pasted image 20210517115651.png]]


#### java  IO、NIO、OKIO
https://segmentfault.com/a/1190000022647582
-   IO 是面向流的，一次一个字节的处理，NIO 是面向缓冲区的，一次产生或消费一个block数据块
-   IO 是阻塞的，NIO 是非阻塞的
-   NIO 支持内存映射方式
-   okio 相比 io 和 nio，api 更简单易用
-   okio 支持超时机制
-   okio 引入 ByteString 空间换时间提高性能
-   okio 采用 segment 机制进行内存共享，节省 copy 时间消耗


#### java异常分类
![[Pasted image 20210519124849.png]]

一、 Error和Exception
Java异常结构中定义有Throwable类。 Exception和Error为其子类。

Error是程序无法处理的错误，比如OutOfMemoryError、StackOverflowError。这些异常发生时， Java虚拟机（JVM）一般会选择终止线程或主程序(要看异常在子线程还是主线程中抛出)。

二、运行异常和非运行时异常
Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。

运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生

三、检查异常和非检查异常
1. 检查异常就是编译器要求你必须处置的异常。不知道你编程的时候有没有遇到过，你写的某段代码，编译器要求你必须要对这段代码try...catch，或者throws exception，如果你遇见过，没错，这就是检查异常，也就是说，你代码还没运行呢，编译器就会检查你的代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理
2. 非检查异常有哪些：RuntimeException与其子类，以及错误（Error）

四、异常处理的两个基本原则:
1、尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。
2、不要生吞异常。

五、NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
ClassNotFoundException的产生原因主要是： Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。 解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。 另外还有一个导致ClassNotFoundException的原因就是：当一个类已经被某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。通过控制动态类加载过程，可以避免上述情况发生。（动态加载类时无法从class path中找到报的错误）

NoClassDefFoundError产生的原因在于： 如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError. 造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。（运行时正常方式调用没有找到，打包是漏掉了）


#### JNI
一，如何加载so（java和android）

二，native注册有几种

三，java调用C++

四，C++调用java


#### Java中 long、float 字节数
short s; 2字节
char c; 2字节（C语⾔中是1字节）
int i; 4字节 float f; 4字节
long l; 8字节 double d; 8字节
byte b; 1字节
boolean bool; false/true 1字节