https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/

##### 1.7版本中，HashMap实现原理
![[Pasted image 20210517163057.png]]

一，关键参数
![[Pasted image 20210517163206.png]]
 1. 默认桶大小值(16)，因为底层是数组，所以这个是数组默认的大小
 2. 桶最大值，即数组最大值
 3. 默认的负载因子(0.75)
 4. table真正存放数据的数组
 5. 存放Map数量大小
 6. 桶大小，可以在初始化是显示指定
 7. 负载因子，可以在初始化是显示指定

二，负载因子说明
给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 `16 * 0.75 = 12` 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。


三，Entry结构，成员变量如下
-   key 就是写入时的键。
-   value 自然就是值。
-   开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。
-   hash 存放的是当前 key 的 hashcode。

四，put方法
-   判断当前数组是否需要初始化。
-   如果 key 为空，则 put 一个空值进去。
-   根据 key 计算出 hashcode。
-   根据计算出的 hashcode 定位出所在桶。
-   如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。
-   如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置
- 注意：当调用 addEntry 写入 Entry 时需要判断是否需要扩容，如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位

五，get方法
-   首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。
-   判断该位置是否为链表。
-   不是链表就根据 `key、key 的 hashcode` 是否相等来返回值。
-   为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。
-   啥都没取到就直接返回 null 。

#### 1.8版本对HashMap的演进
当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 `O(N)`

一，1.8 HashMap结构图

![[Pasted image 20210517164538.png]]

二，关键参数

![[Pasted image 20210517165025.png]]
-   `TREEIFY_THRESHOLD` 用于判断是否需要将链表转换为红黑树的阈值。
-   HashEntry 修改为 Node，Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 `key value hashcode next` 等数据。

三，put方法

![[Pasted image 20210517165300.png]]
1.  判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。
2.  根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。
3.  如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 `key、key 的 hashcode` 与写入的 key 是否相等，相等就赋值给 `e`,在第 8 步的时候会统一进行赋值及返回。
4.  如果当前桶为红黑树，那就要按照红黑树的方式写入数据。
5.  如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。
6.  接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。
7.  如果在遍历过程中找到 key 相同时直接退出遍历。
8.  如果 `e != null` 就相当于存在相同的 key,那就需要将值覆盖。
9.  最后判断是否需要进行扩容。

四，get方法

![[Pasted image 20210517165448.png]]

-   首先将 key hash 之后取得所定位的桶。
-   如果桶为空则直接返回 null 。
-   否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。
-   如果第一个不匹配，则判断它的下一个是红黑树还是链表。
-   红黑树就按照树的查找方式返回值。
-   不然就按照链表的方式遍历匹配返回值。

#### HashMap在并发场景下的死循环
https://blog.csdn.net/jiangguilong2000/article/details/43882565
多线程同时put时，如果同时调用了resize操作，可能会导致循环链表产生，进而使得后面get的时候，会死循环。


#### ConcurrentHashMap


