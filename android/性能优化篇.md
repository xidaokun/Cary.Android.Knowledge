
#### 如果发生了异常情况，怎么快速止损
- 功能开关，对于新上线功能加上开关，通过配置中心下发开关来决定是否显示新功能入口
- 如果是Hybrid开发，可以直接更新资源包
- 热更新方式
- 如果以上方式都不可以，可以清理用户缓存数据（主动或被动）


#### Native Crash
-   崩溃过程：native crash 时操作系统会向进程发送信号，崩溃信息会写入到 data/tombstones 下，并在 logcat 输出崩溃日志
-   定位：so 库剥离调试信息的话，只有相对位置没有具体行号，可以使用 NDK 提供的 addr2line 或 ndk-stack 来定位
-   addr2line：根据有调试信息的 so 和相对位置定位实际的代码处
-   ndk-stack：可以分析 tombstone 文件，得到实际的代码调用栈

注意：一般思路拿到崩溃日志，使用响应工具解读日志信息，根据调试tag，关键字或代码调用栈来定位问题


#### 启动任务是怎么异步的，异步遇到问题没有？
-   体现演进过程
-   详细介绍启动器

https://segmentfault.com/a/1190000023688392
减少阻塞型任务的数量，是加速启动最直接的手段。这里需要根据任务的DAG进行依赖分析，能够无伤被延迟执行的任务最明显的特征就是”没有其他任务依赖于它“。如果任务之间有依赖，则需要根据后续首页对于模块的使用情况来决定是否将整个依赖链上的任务全部延迟


我们最初是采用的普通的一个异步的方案，即new Thread + 设置线程优先级为后台线程的方式在Application的onCreate方法中进行异步初始化，后来，我们使用了线程池、IntentService的方式，但是，在我们应用的演进过程当中，发现代码会变得不够优雅，并且有些场景非常不好处理，比如说多个初始化任务直接的依赖关系，比如说某一个初始化任务需要在某一个特定的生命周期中初始化完成，这些都是使用线程池、IntentService无法实现的。所以说，我们就开始思考一个新的解决方案，它能够完美地解决我们刚刚所遇到的这些问题。

这个方案就是我们目前所使用的启动器，在启动器的概念中，我们将每一个初始化代码抽象成了一个Task，然后，对它们进行了一个排序，根据它们之间的依赖关系排了一个有向无环图，接着，使用一个异步队列进行执行，并且这个异步队列它和CPU的核心数是强烈相关的，它能够最大程度地保证我们的主线程和别的线程都能够执行我们的任务，也就是大家几乎都可以同时完成


#### 版本迭代导致启动变慢有什么好的解决方式
- 启动器，解决启动任务变多导致启动变慢问题
- CI限制，对一些启动类做修改限制，确认其他人员对这部分修改能否优化(能否延迟初始化，懒加载)
- 线上监控，监控启动类的每个生命周期之间间隔，如果发现启动变慢，可以根据周期时间间隔变化查找问题所在，以便优化


##### 内存优化
一，如何避免内存抖动？（代码注意事项）

内存抖动是由于短时间内有大量对象进出新生区导致的，它伴随着频繁的GC，gc会大量占用ui线程和cpu资源，会导致app整体卡顿。

避免发生内存抖动的几点建议：

-   尽量避免在循环体内创建对象，应该把对象创建移到循环体外。
-   注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。
-   当需要大量使用Bitmap的时候，试着把它们缓存在数组或容器中实现复用。
-   对于能够复用的对象，同理可以使用对象池将它们缓存起来

二，如何做内存分析

#### App绘制优化


#### App瘦身
**Android Studio 自带的 Analyze APK 来做的包体积分析**，主要就是做了代码、资源、So 等三个方面的重点优化
 - 代码方面
  1. proguard混淆
   ProGuard 可以从你打包的应用程序检测和删除未使用的类、字段、方法和属性，当然也会包括libraries里的，这样对64K引用限制很有帮助的。ProGuard 也会优化字节码，把类、字段、属性和方法用短的名称表示-**混淆**（官方文档上也说了还有删除未使用的代码指令，这个有时间再研究下了）
   2. 统一资源库
    剔除功能相同，但实现不一样的库；比如友盟和qqbugly
	
- 删除无用资源，做资源混淆
- 多屏幕密度资源共用
- 压缩PNG和JPEG文件或使用矢量图
您可以使用 [pngcrush](http://pmt.sourceforge.net/pngcrush/)、[pngquant](https://pngquant.org/) 或 [zopflipng](https://github.com/google/zopfli) 等工具缩减 PNG 文件的大小，同时不损失画质。所有这些工具都可以缩减 PNG 文件的大小，同时保持肉眼感知的画质不变
- so库，只保留armeabi
1. 如果项目中使用了第三方SDK或者NDK，如果不配置cpu架构，可能就会导入全部的so库文件，这时候可以在gradle中配置，选择特定的so库打包到apk中，这块瘦身效果是很可观的
2. 兼容性
  x86\_64兼容x86
  armeabi几乎可以兼容所有机型
  armeabi-v7a兼容armeabi
  arm64-v8a兼容armeabi-v7a
3. x86一般是模拟器所以我们可以只留一份armeabi，arm64-v8a或者armeabi-v7a中的一个即可。现在是主流手机基本都是armeabi-v7a以上了，谷歌play已经要求所有apk必须适配arm64-v8a的cpu
4. 也可以构建的时候分包，利用应用市场来动态分发apk


#### 网络优化
 一，网络监控
  1. 质量监控，DNS解析时间、建立连接时间，接口异常
  2. 流量监控

二，如何降低流量消耗
  1. 数据：缓存 + 增量更新(比如分页加载)
  2. 上传：压缩
  3. 图片：缩略图、webp策略

三，如何定位线上耗流量问题
  1. 精准获取消耗流量，排查用户流量消耗是否异常
  2. 监控网络请求，根据网络请求次数和大小，定位哪部分逻辑出了问题
  3. 主动预警

四，优化点
 1. 连接复用， 节省连接建立时间
 2. 请求合并，多个请求合并为一个请求
 3. 压缩请求数据大小，比如body做gzip压缩
 4. 根据网络情况判断下载什么质量图片
 5. 使用HttpDNS优化DNS，DNS存在解析慢和DNS劫持等问题，HTTPDNS 则不同，顾名思义它是利用 HTTP 协议与 DNS 服务器的 80 端口进行交互。不走传统的 DNS 解析，从而绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率（关键点，不走运营商的LocalDNS）

五，扩展：精准获取流量消耗
https://blog.csdn.net/baidu_31093133/article/details/79370844
1. PackageManager + FlowInfo
通过PackageManager拿到uid，然后更具uid拿到流量消耗
2. 代码 **插桩** 从底层彻底解决了这些问题，根据规则对 APK 的字节码（ Dex 文件）进行修改，模仿人工，在 APP 每次发送的 HTTP 请求的地方插入监控代码，运行时采集请求数据，并分析流量。

#### 电量优化
电量相关的测试相对来说难度较大，因为 App 在具体手机上的耗电量无法准确统计，每一个手机所使用的硬件不一样，那么它相应的功耗就不一样。而且这个功耗值我们只能在线下通过导出手机的 power\_profile.xml 文件拿到。

1. 网络优化
  -   网络请求的时机以及次数，将可以延迟的网络请求批量发送，减少网络被激活的时机与次数。
  -   此外，我们可以对网络传输数据进行压缩，以降低传输的时间与流量。
  -   最后，一定要禁止使用轮询的方式来做业务操作

2. 传感器
  根据场景谨慎地选择传感器使用的模式，比如说在使用 GPS 的时候一般要避免使用高精度的模式，或者是尽量复用上一次的定位结果
  
3. WakeLock CPU
  我们在实际项目中使用 WakeLock 有几个注意事项，第一，acquire、release 要成对地释放，第二，尽量使用 acquire 的超时方法来设置超时时间，避免因为异常情况从而导致 WakeLock 而无法释放的情况，第三，关于 WakeLock 的释放一定要写在 try-catch-finally 的 finally 当中，保证 WakeLock 在异常情况下的释放。
  
  4. JobScheduler
   JobScheduler 可以允许开发者在符合某些条件下创造执行在后台的任务，我们可以设置执行一些耗电操作的场景，比如说 处于 WIFI 状态下同时连接电源 的情况下。同时，要注意用户在离开界面后，要避免耗电的操作，比如说停止播放动画。通过这些操作，我们的 App 就不会比之前耗电了
   
   总结：
   根本上来讲，较少耗电就要从合理使用硬件模块找解决方案